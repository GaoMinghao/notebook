**模板的特化**  
又被称为全特化，full specialization  
模板的实现中，当T为特定的数据类型时，使用某一种特殊的实现

![Exported image](Exported%20image%2020260212172046-0.png)

**模板的显示完全特化**

![Exported image](Exported%20image%2020260212172050-1.png)

以上是模板的两种显示完全特化（不是很确定模板是不是只有两种显示完全特化，只是说存在这两种），会发现第二种中 test_template==\<std::string\>==，标黄的部分是冗余的，该定义会被编译器当做主模板中某个单一类型实例的实现——编译器根据签名里 std::string& 推断出 T=std::string  
这两种写法是一样的，如下图所示，同时出现的话甚至编译就会报错 redefinition

![Exported image](Exported%20image%2020260212172051-2.png)   
**重载** **vs** **显示完全特化**

![Exported image](Exported%20image%2020260212172053-3.png)

参见图中的例子，对于f(42)，同时存在两个函数，经过重载的 f(int) 和 经过完全特化的 template\<\> f(int)，执行结果如下

![Exported image](Exported%20image%2020260212172054-4.png)

会发现，实际调用的是 overload 的函数，这是因为==重载解析里非模板函数的优先级大于函数模板==。
 
**模板的偏特化**  
指多个泛化的模板参数中的某一个或者几个被固定为了某一种类型  
如下，泛化版本的有两个参数 T 和 Alloc，但是偏特化版本中将 T 锁定为了 bool 值  
参数数量的偏特化

![Exported image](Exported%20image%2020260212172058-5.png)

参数范围的偏特化，例子中从任意的类型，偏特化为指针

![Exported image](Exported%20image%2020260212172102-6.png)