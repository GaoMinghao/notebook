以一个简单的例子，看看TRANS_BLOCK状态是如何跳转的
 
注意标 的方法，不是第一层方法，PG事务的第一层方法只有标 的三个函数
 
==语句====1====：BEGIN====;==  
依次调用  
==StartTransactionCommand==， 状态从 TBLOCK_DEFAULT 转变为 TBLOCK_STARTED  
==B====eginTransactionBlock==，状态从 TBLOCK_STARTED 转变为 TBLOCK_BEGIN，需要注意的是，该方法是由 “BEGIN”这个语句拉起的，不是所有流程里面都会调用这个状态  
==CommitTransactionCommand==, 状态从 TBLOCK_BEGIN 转化为 TBLOCK_INPROGRESS
 
==语句====2====：====Select * from t1;==  
依次调用  
==Start====TransactionCommand==，不做状态转换  
==CommitTransaction====Command==，不做状态转换
 
==语句====3====：====END;==  
依次调用  
==Start====TransactionCommand==，不做状态转换  
==End====TransactionBlock==，状态从 TBLOCK_INPROGRESS 转化为 TBLOCK_END  
中间会做一些操作，没看  
==CommitTransaction====Command==, 状态从 TBLOCK_END 转化为 TBLOCK_DEFAULT  
真正涉及持久化的 commit 实在这个地方做的，是从 TBLOCK_END 转化为 TBLOCK_DEFAULT 之前进行的

![Exported image](Exported%20image%2020260212171511-0.png)  

当语句2发生错误时  
==语句====2====：select== ==* from table t1;==  
依次调用  
==Start====TransactionCommand==，不做状态转换  
此时因为语句出错，走不到 CommitTransactionCommand 去  
==Abort====CurrentTransaction==，状态从 TBLOCK_INPROGRESS 转化为 TBLOCK_ABORT
   

==语句====3====：abort==  
依次调用  
==Start====TransactionCommand==，不做状态转换  
==UserAbortTransactionCommand==，状态从 TBLOCL_ABORT 转化为 TBLOCK_ABORT_END  
==CommitTransaction====Command==, 状态从 TBLOCK_ABORT_END 转化为 TBLOCK_DEFAULT

此时正确操作是 END 或者 ROLLBACK，  
但是假如我们继续执行 select * table t1;  
依次调用  
StartTransactionCommand，不做状态转换  
==Abort====CurrentTransaction==，不做状态转换
 
![Exported image](Exported%20image%2020260212171512-1.png)

上面是使用BEGIN语句显示开启事务块的场景，其实对PostgreSQL来说，如果不显示开启事务块的话，每条语句都是一个事务  
比方说
 
**Insert into t1(1);**
 
这条语句的调用顺序为  
==StartTransactionCommand==， 状态从 TBLOCK_DEFAULT 转变为 TBLOCK_STARTED  
内部调用 StartTransaction  
==CommitTransactionCommand==, 状态从 TBLOCK_STARTED 转化为 TBLOCK_DEFAULT，就结束了

![Exported image](Exported%20image%2020260212171514-2.png)  

这个描述有点错误的，以上面debug的为准

![[事务分层管理及代码跳转 - Ink.svg]]
